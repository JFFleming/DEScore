#!/usr/bin/perl
use strict;
use warnings;

=pod

=head1 NAME

DE-Score Calculator - Quantifying site saturation in amino acid sequence alignments

=head1 SYNOPSIS

  perl DEScoreCalculator.pl <alignment.fasta> <output_prefix>

=head1 DESCRIPTION

The DE-Score Calculator computes a novel entropic site saturation metric
for amino acid sequence alignments. The DE-Score is a measure of site
saturation based on the relative frequency of within-category versus
between-category amino acid substitutions.

This script accepts a multiple sequence alignment in FASTA format and
calculates the between category/within category ratio (the DaCER), and its 
standard deviation, as well as taxon-specific DaCER, Taxon-specific DE-Scores
and a dataset-wide DE-Score and critical DE-Score threshold.

The difference between a DE-Score and a DaCER is that the DE-Score is normalized 
according to the number of taxa in the alignment, allowing for comparisons across 
datasets of different sizes. DE-Scores of below 0 represent datasets or sequences that
are significantly affected by entropic site saturation.

=head1 INPUT

=head2 Alignment file

A multiple sequence alignment in FASTA format containing amino acid
sequences. These sequences must all be the same length.

=head2 Output prefix

A string used as the prefix for all output files generated by DEScoreCalculator.

=head1 OUTPUT

"Results.SiteSaturation.TotalFrequencies.txt" and "Results.SiteSaturation.TaxaFrequencies.txt".

Inside Results.SiteSaturation.TotalFrequencies.txt you will find a table showing the Dayhoff 
Exchange Frequency, Dayhoff Exchange Frequency Standard Deviation and the DE-Score of the entire 
dataset. Inside Results.SiteSaturation.TaxaFrequencies.txt you will find the same, but 
for each taxa in your dataset instead.

=head1 METHOD SUMMARY

The DE-Score is calculated as the normalized distance between the observed Dayhoff 
category exchange frequency and the Dayhoff saturation threshold (0.177).
This can be compared to a critical threshold derived from simulation data - the DE-Score 
if the Dayhoff category exchange frequency of the dataset is 0.265. Datasets with 
DE-Scores below this threshold can be considered critically saturated.

=head1 VERSION

Version 1.5 (October 14, 2025)

=head1 AUTHORS

James F. Fleming  
Torsten H. Struck

=head1 CONTACT

For questions, comments, or bug reports, please contact:

j.fleming@ub.edu

=head1 LICENSE

This script is provided for academic and research use.
Please cite the appropriate publication if you use this software in
published work. (Publication is under review)

=head1 SEE ALSO

perldoc, pod2man, pod2html

=cut

my $version   = "1.6";
my $DEFAULT_FASTA_NAME = "test.fasta";
my $DEFAULT_FASTA = <<'FASTA';

>Taxon1
HFIFGLSICSGIKGLRTPSNLFIINLFPNSYQTQWAFGSLVVKGIDYLSQDIFNRGAPAAEFKKKAKEMNVASLRGNEEKTASVPKRAGT
>Taxon2
HFIFGLSICSGIKALRTPSNLFIINLFPNSYKTQWAFGSLVVKGIDYLSQDIFNRGAPSAEFKKKAKEMNVASLRGNEEKTASVPKRAGT
>Taxon3
HFIFGLSVCSGIKGLRTPSNLFIINLFPNSYKTQWSFGSLVVKGIDYLSQDLFNRGAPSAEFKKKAKEMNVASLRGNEEKTASVPKRAGT
>Taxon4
HFIFGLSICSGIKGLRTPSNLFIINLFPNSYRTQWSFGSLVVKGIDYLSQDLFNRGAPAAEFKKKAKEMNVASLRGNEEKTASVPKRAGT
>Taxon5
HFIFGLSICGGTKGLRTPSNIFVINLFPNSYYQHWALGSFIVKFIDSLSDGFYNKGAPSAEFKRKAKEMNVASLRGNEEKTAAVPKRSAT
>Taxon6
HFIFGLCICAGTKSLRTPSNIFVINLFPNSYFKYWALGPFVVKAIDSLSEGFYNRGAPTAEFKKKAKEMNVASLRGNEEKTASVPKRSAI

FASTA

print "
DE-Score Calculator Version $version, James F. Fleming and Torsten H. Struck, 2025.
Welcome to the DE-Score Calculator. DE-Score Calculator accepts amino acid FASTA files as input, and then outputs 2 files.
To run DE-Score Calculator on your data, use the following command:
perl DEScoreCalculator.pl <filename> <prefix for output files>

The 2 output files are:
- <prefix for output files>.SiteSaturation.TaxaFrequencies.txt: This file gives the Within Category/Between Category exchange frequency, the standard deviation of that frequency and the taxon-specific DE-Score for each taxa.
- <prefix for output files>.SiteSaturation.TotalFrequencies.txt: This file gives the Within Category/Between Category exchange frequency, the standard deviation of that frequency and the DE-Score for the whole dataset.

If you have any questions, queries or comments, please don't hesitate to get in touch at:
j.fleming\@ub.edu
";

my ($align_check, $output_check);
if (@ARGV == 1) {
print "Only one argument was provided, sorry. Please note the above command to run DE-Score Calculator. You may have forgotten to specify the alignment file or the output prefix.\n";
exit(1);
}
elsif (@ARGV < 2) {
    print "PLEASE NOTE: No input alignment provided â€” using embedded default FASTA file test.fasta. Output prefix is test_output. The DE-Score of this output file should be 2.54136\n";
    # Write embedded FASTA to a temporary file
    open(my $dfh, ">", $DEFAULT_FASTA_NAME)
        or die "Cannot create default FASTA file\n";
    print $dfh $DEFAULT_FASTA;
    close($dfh);
    $align_check  = $DEFAULT_FASTA_NAME;
    $output_check = "test_output";
} else {
    $align_check  = $ARGV[0];
    $output_check = $ARGV[1];
}
my %phy_seqs = parse_fasta($align_check);

my $freq_file = "$output_check.SiteSaturation.TotalFrequencies.txt";
my $tax_file  = "$output_check.SiteSaturation.TaxaFrequencies.txt";

my $size = keys %phy_seqs;
my $normalisation_constant = 0.255 * $size**-0.15;
my $crit_DaCER             = 0.265;
my $saturation_DaCER       = 0.177;
my $crit = ($crit_DaCER - $saturation_DaCER) / $normalisation_constant;
my $round_crit = sprintf("%.5f", $crit);

open(FREQ, '>', $freq_file) or die "Cannot open $freq_file\n";
print FREQ "FileName\tExchangeFreq\tExchangeFreqStDev\tCriticalDE-Score\tDE-Score\n";

open(TAXA, '>', $tax_file) or die "Cannot open $tax_file\n";
print TAXA "FileName\tExchangeFreq\tExchangeFreqStDev\tDE-Score\n";

my @small        = qw(A G P S T);
my @acid_amide   = qw(D E N Q);
my @basic        = qw(H K R);
my @hydrophobic  = qw(I L V M);
my @aromatic     = qw(F W Y);
my @sulfur       = qw(C);
my @valid_seqs   = qw(A G P S T D E N Q H K R I L V M F W Y C);

# Hashes for fast category lookup
my %valids = map { $_ => 1 } @valid_seqs;

my %category;
$category{$_} = 'small'        for @small;
$category{$_} = 'acid_amide'   for @acid_amide;
$category{$_} = 'basic'        for @basic;
$category{$_} = 'hydrophobic'  for @hydrophobic;
$category{$_} = 'aromatic'     for @aromatic;
$category{$_} = 'sulfur'       for @sulfur;

print "There are $size taxa in this input dataset\n";
print "The Critical DE-Score for this dataset is thereby $round_crit \n";
print TAXA "CRITICAL\t0.266\tN/A\t$round_crit\n";

my $a = 0;
my @all_tvs;
my @all_tis;
my @all_ti_freqs;

my @taxa_ids = sort keys %phy_seqs;
my %taxon_tis;
my %taxon_tvs;
my %taxon_ti_freqs;

# Loop avoiding redundant comparisons (i < j only)
for (my $i = 0; $i < @taxa_ids; $i++) {
    my $id1   = $taxa_ids[$i];
    my @vals1 = @{ $phy_seqs{$id1} };
    my $tracker = $i+1;
	print "Comparing $taxa_ids[$i] Taxon $tracker of $size \n";
    for (my $j = $i + 1; $j < @taxa_ids; $j++) {
        my $id2   = $taxa_ids[$j];
        my @vals2 = @{ $phy_seqs{$id2} };

        my ($pairwise_ti, $pairwise_tv, $pos) = (0, 0, 0);

        for my $aa1 (@vals1) {
            my $aa2 = $vals2[$pos];

            if ($valids{$aa1} && $valids{$aa2}) {
                if ($aa1 eq "-" || $aa2 eq "-") {
                    # skip gaps
                } elsif ($aa1 eq $aa2) {
                    # identical, skip
                } elsif ($category{$aa1} && $category{$aa2} && $category{$aa1} eq $category{$aa2}) {
                    $pairwise_ti++;
                } else {
                    $pairwise_tv++;
                }
            }
            $pos++;
        }

        next if ($pairwise_ti == 0 && $pairwise_tv == 0);

        my $ti_freq = ($pairwise_ti == 0) ? 0 : $pairwise_ti / ($pairwise_ti + $pairwise_tv);

        push @all_tis, $pairwise_ti;
        push @all_tvs, $pairwise_tv;
        push @all_ti_freqs, $ti_freq;

        push @{ $taxon_tis{$id1} }, $pairwise_ti;
        push @{ $taxon_tvs{$id1} }, $pairwise_tv;
        push @{ $taxon_ti_freqs{$id1} }, $ti_freq;

        push @{ $taxon_tis{$id2} }, $pairwise_ti;
        push @{ $taxon_tvs{$id2} }, $pairwise_tv;
        push @{ $taxon_ti_freqs{$id2} }, $ti_freq;
    }
}

foreach my $taxon_id (@taxa_ids) {
    $a++;
    my $tis_ref   = $taxon_tis{$taxon_id}     || [];
    my $tvs_ref   = $taxon_tvs{$taxon_id}     || [];
    my $freq_ref  = $taxon_ti_freqs{$taxon_id}|| [];

    my $avg_freq  = avg($freq_ref);
    my $std_freq  = get_stddev($freq_ref);
    my $tax_dist  = $avg_freq - $saturation_DaCER;
    my $tax_DE    = $tax_dist / $normalisation_constant;
	my $round_avg_freq = sprintf("%.5f", $avg_freq);
	my $round_std_freq = sprintf("%.5f", $std_freq);
	my $round_tax_DE = sprintf("%.5f", $tax_DE);
#    print "\n Finished assessing $taxon_id. Taxon $a of $size";
    print TAXA "$taxon_id\t$round_avg_freq\t$round_std_freq\t$round_tax_DE\n";
}

print "\n";

# Whole dataset DE-Score
my $average_ti_freq = avg(\@all_ti_freqs);
my $std_ti_freq     = get_stddev(\@all_ti_freqs);
my $freq_dist       = $average_ti_freq - $saturation_DaCER;
my $total_DE        = $freq_dist / $normalisation_constant;
my $round_average_ti_freq = sprintf("%.5f", $average_ti_freq);
my $round_std_ti_freq     = sprintf("%.5f", $std_ti_freq);
my $round_total_DE = sprintf("%.5f", $total_DE);

print FREQ "$align_check\t$round_average_ti_freq\t$round_std_ti_freq\t$round_crit\t$round_total_DE\n";

### Math functions ###
sub avg {
    my ($arr_ref) = @_;
    my $count = @$arr_ref;
    return 0 if $count == 0;
    my $sum = 0;
    $sum += $_ for @$arr_ref;
    return $sum / $count;
}

sub get_stddev {
    return sqrt(get_disp(@_));
}

sub get_disp {
    my ($arr_ref) = @_;
    my $mean  = avg($arr_ref);
    my $count = @$arr_ref;
    return 0 if $count == 0;
    my $sum = 0;
    $sum += ($_ - $mean) ** 2 for @$arr_ref;
    return $sum / $count;
}

### FASTA Parser ###
sub parse_fasta {
    my ($file) = @_;
    my %sequences;
    open(my $fh, "<", $file) or die "Cannot open FASTA file $file\n";

    my ($id, $seq) = ("", "");

    while (my $line = <$fh>) {
        chomp($line);
        if ($line =~ /^>(\S+)/) {
            if ($id ne "") {
                $sequences{$id} = [split //, $seq];
            }
            $id = $1;
            $seq = "";
        } else {
            $seq .= $line;
        }
    }

    if ($id ne "") {
        $sequences{$id} = [split //, $seq];
    }

    close($fh);
    return %sequences;
}
